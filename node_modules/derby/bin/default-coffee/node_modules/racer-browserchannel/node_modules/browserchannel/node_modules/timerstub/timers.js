// Generated by CoffeeScript 1.6.1
var immediate, insert, lastId, now, queue;

now = 1000000;

queue = [];

lastId = 0;

immediate = setImmediate || process.nextTick;

insert = function(time, fn, repeat, id) {
  var i;
  i = 0;
  while (i < queue.length && queue[i][0] <= time) {
    ++i;
  }
  if (id == null) {
    id = ++lastId;
  }
  if (repeat == null) {
    repeat = 0;
  }
  queue.splice(i, 0, [time, fn, repeat, id]);
  return id;
};

exports.setTimeout = function(fn, timeout) {
  if (typeof fn === 'string') {
    fn = function() {
      return eval(fn);
    };
  }
  if (timeout === 0) {
    return immediate(fn);
  } else {
    return insert(now + timeout, fn);
  }
};

exports.clearTimeout = function(id) {
  var e;
  queue = (function() {
    var _i, _len, _results;
    _results = [];
    for (_i = 0, _len = queue.length; _i < _len; _i++) {
      e = queue[_i];
      if (e[3] !== id) {
        _results.push(e);
      }
    }
    return _results;
  })();
};

exports.setInterval = function(fn, timeout) {
  if (timeout === 0) {
    throw new Error('Timer stubs dont support setInterval(fn, 0)');
  }
  if (typeof fn === 'string') {
    fn = function() {
      return eval(fn);
    };
  }
  return insert(now + timeout, fn, timeout);
};

exports.clearInterval = exports.clearTimeout;

exports.Date = function(time) {
  return new Date(time != null ? time : now);
};

exports.Date.now = function() {
  return now;
};

exports.wait = function(amt, callback) {
  var waitInternal;
  waitInternal = function(amt) {
    var fn, id, repeat, time, _ref;
    if (!(typeof amt === 'number' && amt >= 0)) {
      throw new Error('amt must be a positive number');
    }
    if (queue.length > 0 && now + amt >= queue[0][0]) {
      _ref = queue.shift(), time = _ref[0], fn = _ref[1], repeat = _ref[2], id = _ref[3];
      amt -= time - now;
      now = time;
      if (repeat) {
        insert(now + repeat, fn, repeat, id);
      }
      fn();
      return immediate(function() {
        return waitInternal(amt, callback);
      });
    } else {
      now += amt;
      if (callback != null) {
        return callback();
      }
    }
  };
  return immediate(function() {
    return waitInternal(amt);
  });
};

exports.waitAll = function(callback) {
  if (queue.length === 0) {
    if (callback != null) {
      return immediate(callback);
    }
  } else {
    return exports.wait(queue[0][0] - now, function() {
      return exports.waitAll(callback);
    });
  }
};

exports.clearAll = function() {
  return queue = [];
};
